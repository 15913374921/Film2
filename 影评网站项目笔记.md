# 影评项目笔记

 **技术栈** 

● 后端：Springboot2 + Mybatis-Plus + JWT + Sa-Token + Redis

● 前端：Vue3 + Element-Plus + Vite + Pinia

● 数据库：Mysql5.7+

 **开发工具** 

Idea + WebStorm（VSCode） + Navicat + nodejs + JDK1.8

 基础环境搭建

## 1.脚手架搭建和登录

**代码生成器**

加上 `static` 和不加 `static` 的区别：

### 1. 加上 `static` 的情况：

```java
private static final String PACK_NAME = "com.example.partner";
```

- **属于类**：`PACK_NAME` 是一个类变量（静态变量），它属于类本身，而不是某个类的实例。无论创建多少个实例，`PACK_NAME` 的值在所有实例中都是共享的。
- **可以通过类名直接访问**：即使没有创建类的实例，也可以通过 `ClassName.PACK_NAME` 来直接访问该变量，因为它是类级别的。
- **内存占用**：静态变量会在类加载时分配内存，只会在内存中存储一份。

### 2. 不加 `static` 的情况：

```java
private final String PACK_NAME = "com.example.partner";
```

- **属于实例**：`PACK_NAME` 是一个实例变量，它属于某个类的实果创建多个实例，每个实例都会有自己独立的 `PACK_NAME` 变量，虽然值是相同的，但每个实例占有独立的内存空间。

- **只能通过实例访问**：无法通过类名直接访问该变量，必须创建类的实例后，通过实例对象访问。

  例如：

  ```java
  MyClass obj = new MyClass();
  String packName = obj.PACK_NAME;
  ```

- **内存占用**：每个实例都会有自己的变量副本，这意味着如果创建很多实例，会浪费内存，因为每个实例都保存了相同的值。



**执行代码生成器时出现 freemarker/template/Configuration**

```
<dependency>
    <groupId>org.freemarker</groupId>
    <artifactId>freemarker</artifactId>
    <version>2.3.28</version>
        <scope>compile</scope>
</dependency>
```

导入依赖即可

**执行代码生成器生成的代码**

出现以下错误

```
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userController': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'userServiceImpl': Unsatisfied dependency expressed through field 'baseMapper'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.example.partner.mapper.UserMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
	at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.postProcessProperties(CommonAnnotationBeanPostProcessor.java:332) ~[spring-context-5.3.23.jar:5.3.23]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.23.jar:5.3.23]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.23.jar:5.3.23]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.23.jar:5.3.23]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.23.jar:5.3.23]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.23.jar:5.3.23]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.23.jar:5.3.23]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.23.jar:5.3.23]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:955) ~[spring-beans-5.3.23.jar:5.3.23]
```

**原因：找不到配置依赖，需要在Application加上**

注意 mybatis-plus开启扫描

```java
@MapperScan("com.example.partner.mapper")
```

**文件导入导出**

需要加上依赖

```java
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>5.2.3</version>
</dependency>
```

## 3.Vue

**vue官网：**https://cn.vuejs.org/guide/quick-start.html

**npm 淘宝镜像：**

```
npm config set registry https://registry.npmmirror.com
```

axios安装：

```
npm i axios -s
```

**element-plus安装：**

```
npm install element-plus --save
```

引入element-plus：

```js
import ElementPlus from 'element-plus' 

import 'element-plus/dist/index.css'

app.use(ElementPlus)
```

**引入icon图标：**

```
npm install @element-plus/icons-vue
import * as ElementPlusIconsVue from '@element-plus/icons-vue'
```



## 4.登录注册

UI网站：https://webgradients.com/

**极简登录源码**

```vue
<template>
  <div style="height: 100vh;overflow: hidden; position: relative; background-color: #eee;">
    <div class="form-box">
      <el-form>
        <h2 style="text-align: center;">后台登录</h2>
        <el-form-item prop="account">
          <el-input v-model="form.account" prefix-icon="el-icon-user" placeholder="请输入账号"></el-input>
        </el-form-item>
        <el-form-item prop="password">
          <el-input v-model="form.password" show-password prefix-icon="el-icon-lock" placeholder="请输入密码"
            autocomplete="new-password"></el-input>
        </el-form-item>
        <div style="margin-bottom: 0.83em">
          <el-button style="width: 100%" type="primary">登录</el-button>
        </div>
      </el-form>
    </div>
  </div>
</template>

<script setup>
    import { reactive } from 'vue';

    const form = reactive({})
</script>

<style scoped>
    .form-box {
        width: 300px; 
        border-radius: 10px; 
        margin: 0 auto; 
        background-color: white; 
        padding: 20px;
        position: absolute; 
        top: 50%; 
        left: 50%; 
        transform: translateX(-50%) translateY(-50%); 
        box-shadow: 0 0 15px -2px rgba(0,0,0,.5);
    }
</style>
```

在Vue和Element Plus中，**`<el-form>`的`:model`属性**是非常的，它用来绑定表单的**数据模型**，这个模型表单着表单每个字段的值。`form`是这个模型对象，表单重要输入的数据。如果不绑定`:model`，表单项就无法正常工作，许多表单相关的功能，例如输入绑定、验证等都无法生效。

### 1. `:model="form"`其目的：

1. **数据绑定**：将表单的输入项（如`<el-input>`、`<el-select>`等）与`form`对象的属性绑定，使得用户输入可以实时更新到`form`对象中。
2. **表单验证**：`Element Plus`表单验证的功能依赖于`:model`。验证规则 ( `rules`) 会根据`form`中的字段来校验数据。因此，**如果没有`:model`，表单验证将无法工作**。

### 2. **为什么要用`@Resource`？**

`@Resource`是Java中用于依赖注入的一种注解，主要用于将某个类的实例注入到当前类中，以实现类与类之间的解耦合。它属于Java的标准注解，由`javax.annotation.Resource`包提供。

1.**简化依赖管理**：使用`@Resource`注解可以自动注入依赖，而不需要手动创建对象，简化了依赖关系的管理。

2.**修改耦合**：通过接口注入，可以使得类与类之间的依赖更加灵活和松散。例如，关系`IUserService`是一个接口，可以有不���实现类。你可以松地更换实现类，而不需要注入逻辑。

3.**Java EE标准**：`@Resource`是Java EE中标准的注解，适用于Spring、Java EE等框架。它通常用于资源注入，自动根据名称或类型来注入相应的资源。

### 3. **`login` 方法的异常处理流程**：

```
public User login(User user) {
    User dbUser = null;
    try {
        dbUser = getOne(new UpdateWrapper<User>().eq("username", user.getUsername()));
    } catch (Exception e) {
        throw new RuntimeException("系统异常");
    }
    if (dbUser == null) {
        throw new ServiceException("未找到用户");
    }
    if (!user.getPassword().equals(dbUser.getPassword())) {
        throw new ServiceException("用户名或密码错误");
    }
    return dbUser;
}
```

在该方法中，可能抛出的异常有几种情况：

1. **系统异常**：`getOne()` 可能会抛出异常，被捕获后重新抛出一个 `RuntimeException("系统异常")`。
2. **业务异常**：如果没有找到用户或密码不匹配，方法会抛出 `ServiceException`。

#### 1. **异常传播和捕获**

当 `login` 方法抛出异常时，异常将沿着调用栈向上传播。如果该异常没有在调用方（比如 Controller 层）被捕获处理，Spring 会捕捉到该异常并寻找合适的 `@ExceptionHandler` 来理它。

假设你有一个控制器调用 `login` 方法

```
@RestController
public class UserController {

    @PostMapping("/login")
    public Result login(@RequestBody User user) {
        User dbUser = userService.login(user); // 调用 login 方法
        return Result.success(dbUser);
    }
}
```

当 `userService.login(user)` 方法抛出 `RuntimeException` 或 `ServiceException`，它向上传播，最终传递到 Spring 的异常处理机制。

#### 2. **`@ExceptionHandler` 捕获异常**

如果你在控制器中或者全局范围内定义了一个 `@ExceptionHandler` 方法，比如：

```
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public Result handleException(Exception e) {
        log.error("未知错误", e); // 记录异常日志
        return Result.error("系统错误"); // 返回错误信息
    }

    @ExceptionHandler(ServiceException.class)
    public Result handleServiceException(ServiceException e) {
        log.warn("业务异常: {}", e.getMessage());
        return Result.error(e.getMessage()); // 返回自定义的业务错误信息
    }
}
```

#### 3. 工作流程：

1. **抛出异常**：当 `login` 方法抛出 `RuntimeException("系统异常")` 或 `ServiceException("未找到用户")` 时��异常会沿着调用链向上传播到控制器层。

2. 寻找 `@ExceptionHandler`

   ：Spring 框架会自动扫描，并尝试寻找控制器类或全局范围内的 

   ```
   @ExceptionHandler
   ```

    方法。这里，

   ```
   @RestControllerAdvice
   ```

    的类 

   ```
   GlobalExceptionHandler
   ```

    就是全局异常处理器。

   - 如果 `login` 方法抛出了 `ServiceException`，Spring 会找到 `handleServiceException(ServiceException e)` 来处理这个异常。
   - 如果抛出的是其他异常（如 `RuntimeException`），Spring 会匹配到 `handleException(Exception e)`。

3. **执行异常处理方法**：找到合适的异常处理器后，Spring 会调用 `@ExceptionHandler` 标记的方法，将异常信息传递给它。在 `handleException` 或 `handleServiceException` 方法中，你可以记录日志、返回自定义的错误信息等。

#### 4. **完整流程示例**

1. 用户向 `/login` 端点发送请求，并提交了用户信息。
2. `login` 方法执行查询操作，假设查询用户时发生了数据库异常或业务逻辑错误。
3. `login` 方法抛出异常，Spring 接收到该异常，并查找是否有适合的 `@ExceptionHandler` 方法。
4. 如果找到了匹配的异常处理器，Spring 调用该处理器，并返回处理后的错误响应（如 `Result.error()`）给前端。

**示例：**

如果抛出 `ServiceException("用户名或密码错误")`，`handleServiceException` 将捕获该异常，返回类似以下的响应：

```
json复制代码{
    "status": "error",
    "message": "用户名或密码错误"
}
```

如果抛出 `RuntimeException("系统异常")`，`handleException` 将捕获该异常，返回类似以下的响应：

```
json复制代码{
    "status": "error",
    "message": "系统错误"
}
```

#### 5. **总结**

- **Spring 的 `@ExceptionHandler` 机制**：在你的 `login` 方法中抛出的异常，最终会由 `@ExceptionHandler` 方法捕获处理。
- **异常传播**：异常从 `login` 方法传播到控制器，控制器没有捕获，Spring 会自动寻找合适的 `@ExceptionHandler`。
- **`@ExceptionHandler` 捕获顺序**：Spring 会根据异常类型找到最合适的 `@ExceptionHandler`，并将异常传递给它处理。

## 5. Pinia

官方文档：https://pinia.vuejs.org/zh/index.html

安装： npm install pinia

```js
// 在vue main.js里使用
import { createPinia } from 'pinia'
const pinia = createPinia()
 
createApp(App).use(pinia).mount('#app')
```

```js
import { defineStore } from 'pinia'   // 导入 defineStore

// 你可以对 `defineStore()` 的返回值进行任意命名，但最好使用 store 的名字，
// 同时以 `use` 开头且以 `Store` 结尾。(比如 `useUserStore`，
// `useCartStore`，`useProductStore`)
// 第一个参数是你的应用中 Store 的唯一 ID。
export const useUserStore = defineStore('user', {
  // 其他配置...
})
```

 **数据持久化** 

```js
//安装插件
npm i  pinia-plugin-persistedstate

// main.js 引用
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)
app.use(pinia)
//安装插件
npm i  pinia-plugin-persistedstate

// main.js 引用
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)
app.use(pinia)

```

```
const useHomeStore = defineStore("home",{
  // 开启数据持久化
  persist: true
  // ...省略
});
```

## 6.使用TMDB的API数据库

**config配置文件**

```java
package com.example.partner.common;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

import java.time.Duration;

//  配置RestTemplate，
@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .setConnectTimeout(Duration.ofSeconds(5000)) // 连接超时
                .setReadTimeout(Duration.ofSeconds(5000))    // 读取超时
                .build();
    }
}

```

### TMDB配置的完善过程

**我们需要创建一个服务类，来请求TMDB的API**

```java
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.beans.factory.annotation.Value;

@Service
public class TmdbService {

    @Value("${tmdb.api.key}")
    private String apiKey;

    private final String BASE_URL = "https://api.themoviedb.org/3";

    private final RestTemplate restTemplate;

    public TmdbService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public String getMovieDetails(Long movieId) {
        String url = BASE_URL + "/movie/" + movieId + "?api_key=" + apiKey;
        return restTemplate.getForObject(url, String.class);
    }

   
}

```

**Spring Boot 应用程序中配置一个 bean 来发出 HTTP 请求**

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

```

**application.yml**

```java
tmdb.api.key=your_tmdb_api_key_here
```

**创建一个测试API请求的控制类**

```java
 private final TmdbService tmdbService;

    @Autowired
    public WebController(TmdbService tmdbService) {
        this.tmdbService = tmdbService;
    }

    @ApiOperation(value = "获取电影详情", notes = "根据电影 ID 获取电影详细信息")
    @GetMapping("/movie/{id}")
    public String getMovie(@PathVariable Long id) {
        return tmdbService.getMovieDetails(id);
    }
```

在执行过程中，会出现连接超时的错误，修改超时设置，无法解决

错误：I/O error on GET request for "https://api.themoviedb.org/3/movie/1": Connection timed out: connect; nested exception is java.net.ConnectException: Connection timed out: connect

通过在浏览器执行

https://api.themoviedb.org/3/movie/1?api_key=YOUR_API_KEY_HERE 发现访问成功（使用了VPN）

在idea控制台输入 
curl https://api.themoviedb.org/3/movie/2?api_key=1ad3fcc3a67f178a8c8958896787f031发现访问也成功

因此断定，尽管 `curl` 可以通过 VPN 访问 API，但 Java 应用默认不会使用系统的代理设置。你需要为 Java 配置代理或确保它使用系统代理。

```java
package com.example.partner.service;

import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.beans.factory.annotation.Value;

import java.net.InetSocketAddress;
import java.net.Proxy;

@Service
public class TmdbService {

    @Value("${tmdb.api.key}")
    private String apiKey;

    private final String BASE_URL = "https://api.themoviedb.org/3";

    private final RestTemplate restTemplate;

    // 使用代理创建 RestTemplate
    public TmdbService() {
        this.restTemplate = createRestTemplateWithProxy();
    }

    private RestTemplate createRestTemplateWithProxy() {
        // 创建一个代理对象，指向 Clash 的本地地址和端口
        Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", 7890)); // Clash 的 HTTP 代理

        // 使用代理创建请求工厂
        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
        requestFactory.setProxy(proxy);

        return new RestTemplate(requestFactory);
    }

    public String getMovieDetails(Long movieId) {
        String url = BASE_URL + "/movie/" + movieId + "?api_key=" + apiKey;
        return restTemplate.getForObject(url, String.class);
    }

    // 你可以为其他端点（如热门电影、搜索等）创建其他方法
}

```

在java里配置了代理，使用的是clash，最终问题解决

## 7.为用户设置一个唯一的标识和逻辑删除

发生数据移时，可能会更换键，为了能更快的找到用户。我们可以设置一个唯一的标识uid

### 逻辑删除的特点

1. **数据保留**：在逻辑删除中，数据不会从数据库中物理删除，而是通过一个标志（例如 `deleted` 字段）来表示该条记录已被删除。这使得记录仍然存在于数据库中，但在查询时不会被显示或视为有效数据。
2. **软删除**：逻辑删除也被称为 **软删除**（Soft Delete），因为它不会真正删除记录，而是将其标记为无效。通常通一个布尔值或整数字段（如 `deleted = 1`）来实现。

### 与物理删除的区别

- **物理删除**（Hard Delete）是真正地将记录从数据库中删除，无法恢复。
- **逻辑删除** 只是将记录记为"已删除"，数据依然保留，通常是为了满足数据恢复、审计或历史记录的需求。

我为User 设置了id，username，password，name，uid，deleted，其中deleted的作用是作为软删除，我为它设置了两个唯一索引，一个叫uid_index索引，一个叫username_index索引，username是联合索引，用username和deleted。

在逻辑删除的场景下，可以通过 `deleted` 字段来标记记录是否被"删除"，而不是真正从数据库中移除数据。通常设置 `deleted = 0` 表示未删除，`deleted = 1` 表示已删除。

结合逻辑删除和 ID 删除的场景，可以这样理解：

- **`deleted = 0` 表示数据存在**，也就是该条记录是活跃的，未被删除。
- **`deleted = 1` 表示数据已被逻辑删除**，即该条记录对用户不可见或不可用，但实际仍然存在于数据库中。
- **当你需要删除一条记录时，你可以根据 `id` 执行删除操作**。但逻辑删除并不真正移除数据，而是将 `deleted` 字段更新为 `1`，而非物理删除记录。

这种逻辑删除方式常用于保留历史记录或数据恢复，同时结合唯一索引（如设置的 `username_index`）避免用户名重复问题。

## 8.使用mybatis-plus的时间自动插入

**实体类**

```java
@ApiModelProperty("创建时间")
@Alias("创建时间")
@TableField(fill = FieldFill.INSERT)
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
private LocalDateTime createTime;

@ApiModelProperty("更新时间")
@Alias("更新时间")
@TableField(fill = FieldFill.INSERT_UPDATE)
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
private LocalDateTime updateTime;
```

**工具类**

```java
@Slf4j
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {

    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("开始插入填充...");
        this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        log.info("开始更新填充...");
        this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
    }
}
```

**因为LocalDateTime在返回json时序列化会有问题，会变成数组的形式，需要JsonFormat配置返回的内容**

## 9.邮箱验证

### 9.1 **使用any-rule插件写正则表达式作为邮箱的验证规则**

安装any—rule插件，右键使用

### 9.2 邮箱验证码

**springboots 集成邮箱**（这里以QQ邮箱为例）

**1.添加依赖**

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

**2.application.yml配置**

```java
# 邮箱配置    
mail:
  #配置 SMTP 服务器地址
  host: smtp.qq.com
  # 发送者邮箱
  username: 1477129018@qq.com
  # 配置密码��注意不是真的配置密码，而是刚刚申请的授权码
  password: 
  # 端口号465或587
  port: 587
  # 默认的邮件编码为UTF-8
  default-encoding: UTF-8
  properties:
      mail.smtp.auth: true
      mail.smtp.starttls.enable: true  # 启用TLS
      mail.smtp.ssl.enable: false  # 关闭SSL
```

**3.申请授权码（以QQ邮箱为例）**

登录QQ邮箱 -点击设置 -点击账号 -在**POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务**点击开启POP3/SMTP服务 -然后验证手机号码 -得到授权码（记得保存）

**4.EmailUtils.java**

```java
@Component // @Component 是一个注解，它的作用是将类标记为一个Spring 容器中的组件，使得 Spring 可以自动发现、管理和注入这个类
@Slf4j
public class EmailUtils {

    @Autowired
    JavaMailSender javaMailSender;

    @Value("${spring.mail.username}")
    String username;

    public void sendHtml(String title, String html, String to) {
        MimeMessage mailMessage = javaMailSender.createMimeMessage();
        //需要借助Helper类
        MimeMessageHelper helper = new MimeMessageHelper(mailMessage);
        try {
            helper.setFrom(username);  // 必填
            helper.setTo(to);   // 必填
//            helper.setBcc("密送人");   // 选填
            helper.setSubject(title);  // 必填
            helper.setSentDate(new Date());//发送时间
            helper.setText(html, true);   // 必填  第一个参数要发送的内容，第二个参数是不是Html格式。
            javaMailSender.send(mailMessage);
        } catch (MessagingException e) {
            log.error("发送邮件失败", e);
        }
    }
}
```



### 9.3 post请求和get请求的区别

**对比：`POST` 与 `GET` 的使用场景**

- **GET 请求**：主要用于**获取资源**，或者在不修改服务器数据的情况下发起请求，参数通过 URL 传递，适合请求中包含小量数据且不涉及敏感信息。
- **POST 请求**：更适合用于**提交数据**、**创建资源**、**修改数据**、**触发操作**，数据放在请求体中，适合传输复杂或大量的数据

### 9.4 解决邮箱发送太慢的问题

```java
package com.example.partner.utils;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.internet.MimeMessage;
import java.util.Date;

@Component // @Component 是一个注解，它的作用是将类标记为一个Spring 容器中的组件，使得 Spring 可以自动发现、管理和注入这个类
@Slf4j
public class EmailUtils {

    @Autowired
    JavaMailSender javaMailSender;

    @Value("${spring.mail.username}")
    String username;

    public void sendHtml(String title, String html, String to) {
        // 设置 DNS 问题的属性
        System.getProperties().setProperty("mail.mime.address.usecanonicalhostname", "false");
        MimeMessage mailMessage = javaMailSender.createMimeMessage();
        Session session = mailMessage.getSession();
        // 设置 日志打印控制器
        session.setDebug(true);
        //  自动获取本地 IP 并设置
        try {
            InetAddress localHost = InetAddress.getLocalHost();
            String localIp = localHost.getHostAddress();
            session.getProperties().setProperty("mail.smtp.localhost", localIp);
            log.info("本地 IP 地址已设置为: {}", localIp);
        } catch (UnknownHostException e) {
            log.error("获取本地 IP 地址失败", e);
        }


        //需要借助Helper类
        MimeMessageHelper helper;
        try {
            helper = new MimeMessageHelper(mailMessage, true);
            helper.setFrom(username);  // 必填
            helper.setTo(to);   // 必填
//            helper.setBcc("密送人");   // 选填
            helper.setSubject(title);  // 必填
            helper.setSentDate(new Date());//发送时间
            helper.setText(html, true);   // 必填  第一个参数要发送的内容，第二个参数是不是Html格式。
            javaMailSender.send(mailMessage);
        } catch (MessagingException e) {
            log.error("发送邮件失败", e);
        }
    }
}
```

1. **`mail.mime.address.usecanonicalhostname = false`** 的作用

- **问题**：默认情况下，JavaMail 会尝试解析发件机器的完全限定域名（Canonical Hostname）。这需要通过 DNS 查找来获取本地主机名。如果 DNS 配置不当或 DNS 服务器响应缓慢，可能会导致邮件发送速度变慢。
- **解决**：通过将 `mail.mime.address.usecanonicalhostname` 设置为 `false`，你避免了这一过程，JavaMail 不再尝试解析本地主机的完全限定域名，跳过了这个耗时的步骤。

2. **手动设置 `mail.smtp.localhost`**

- **问题**：JavaMail 会自动尝试解析并获取本地计算机的主机名（localhost）。这有时需要 DNS 查找，特别是当 DNS 配置不正确或系统无法快速解析本地主机名时，可能会引起延迟，尤其是网络环境不理想或没有正确配置 DNS 的情况下。
- **解决**：通过手动指定一个本地 IP 地址（如 `192.168.1.100`），你告诉 SMTP 客户端跳过本地主机名的解析过程，直接使用该 IP 地址。这大大减少了因为 DNS 查找不畅造成的延迟。

### 9.5 设置一个跟用户请求相关的数据

把参数的对象和数据库的数据分开，比如需要用到emailCode来验证邮箱，但是emailCode不在数据库里，那么我们可以写一个UserRequest，来存储相关的信息

## 10.优化登录时间

在第一个用户登录时，时间会比较慢，在后面用户登录时间变快

在重启后的第一次访问，发现在启动的信息里，在数据库耗时较多，同时可以通过初始化DispatcherServlet来优化登录时间

在**application.yml**的**mvc**添加如下配置

```java
servlet:
  load-on-startup: 1 # 初始化DispatcherServlet，优化时间
```

**数据库的优化**在**application.yml**的datasource添加如下配置

```java
hikari: # 初始化数据库连接，优化时间
  minimum-idle: 10
  connection-test-query: SELECT 1
```

当以上方法不行时，可以通过手动连接数据库来优化登录时间

```java
package com.example.partner.common;

import com.example.partner.entity.User;
import com.example.partner.service.IUserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class InitRunner implements ApplicationRunner {
    
    @Autowired
    IUserService userService;
    
    // 在项目启动成功后会执行该方法
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 在项目启东时进行一次数据库查询，防止懒加载
        User user = userService.getById(1);
        log.info("启动目数据库连接成功");
    }
}
```

通过debug启动项目，发现大部分时间花在了web连接和请求上，通过初始web连接来优化

```java
// 发送一次异步web请求，初始化web连接
ThreadUtil.execAsync(() -> {
    HttpUtil.get("http://localhost:9090/");
    log.info("启动项目Tomcat连接成功");
});
```

最后优��，由于在数据库初始化时，我们只需进行数据库的查询，不需要进行业务表User的查询，因此，我们在UserMapper进行数据库的查询返回一个1，如果查询数据库表可能会发生数据库敏感信息泄露

```java
package com.example.partner.common;

import cn.hutool.core.thread.ThreadUtil;
import cn.hutool.http.HttpUtil;
import com.example.partner.entity.User;
import com.example.partner.mapper.UserMapper;
import com.example.partner.service.IUserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component
@Slf4j
public class InitRunner implements ApplicationRunner {

    @Resource
    UserMapper userMapper;

    // 在项目启动成功后会执行该方法
    @Override
    public void run(ApplicationArguments args) throws Exception {

        try {
            // 在项目启东时进行一次数据库查询，防止懒加载
            userMapper.select1();
            log.info("启动项目数据库连接成功");
            // 发送一次异步web请求，初始化web连接
            HttpUtil.get("http://localhost:9090/");
            log.info("启动项目Tomcat连接成功");
        } catch (Exception e) {
            log.info("优化时间失败",e);
        }


    }
}
```

```xml
package com.example.partner.mapper;

import com.example.partner.entity.User;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author LZY
 * @since 2024-09-19
 */
public interface UserMapper extends BaseMapper<User> {

    int select1();

}
```

## 11.集成Redis

在项目目录下创建bash文件，将startRedis.bat文件复制到该目录下

```text
cd D:\Redis // 根据自己的下载目录选择
redis-server redis.windows.conf
```

控制台输入startRedis.bat启动

PS D:\毕设\partner> cd .\bash\ 
PS D:\毕设\partner\bash> ./startRedis.bat

在pom.xml配置依赖

```java
<!-- Redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
    
<!-- 连接池子 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

application.yml配置：

```yml
redis:
  # Redis数据库索引（默认为0）
  database: 0
  # Redis服务器地址
  host: 127.0.0.1
  # Redis服务器连接端口
  port: 6379
  # Redis服务器连接密码（默认为空）
  # password:
  # 连接超时时间
  timeout: 10s
  lettuce:
    pool:
      # 连接池最大连接数
      max-active: 200
      # 连接池最大阻塞等待时间（使用负值表示没有限制）
      max-wait: -1ms
      # 连接池中的��大空闲连接
      max-idle: 10
      # 连接池中的最小空闲连接
      min-idle: 0
```

RedisUtils:

**邮箱验证码存储**

在先前是使用CODE_MAP来存储验证码和时间戳，但是项目重启后就会消失，为了保证数据的可持久性，可以通过将验证码相关信息存储到redis中

```java
// 设置redis缓存
 @Autowired
RedisTemplate<String, Integer> redisTemplate;
String EmailPrefix = EmailCodeEnum.getValue(type);
String key = Constants.EMAIL_CODE + EmailPrefix + email;
redisTemplate.opsForValue().set(key,code,TIME_IN_MS5, TimeUnit.MILLISECONDS);
```

constants.java 用来拼写前缀

```java
package com.example.partner.common;

public interface Constants {

    String EMAIL_CODE = "email.code.";
}
```

EmailCodeEnum.java 用来获取邮箱使用类型和返回类型作为拼接的前缀

```java
package com.example.partner.common.enums;

import lombok.Getter;

@Getter
public enum EmailCodeEnum {

    REGISTER("REGISTER","register:"),
    RESETPASSWORD("RESETPASSWORD","resetPassword:"),
    UNKNOWN("","");
    private String type;
    private String value;

    EmailCodeEnum(String type,String value) {
        this.type = type;
        this.value = value;
    }

    public static String getValue(String type) {
        EmailCodeEnum[] values = values();
        for (EmailCodeEnum codeEnum : values) {
            if(type.equals(codeEnum.type)) {
                return codeEnum.value;
            }
        }
        return "";
    }

    public static EmailCodeEnum getEnum(String type) {
        EmailCodeEnum[] values = values();
        for (EmailCodeEnum codeEnum : values) {
            if(type.equals(codeEnum.type)) {
                return codeEnum;
            }
        }
        return UNKNOWN;
    }
}

```

RedisConfig.java

```java
package com.example.partner.common;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;

@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate redisTemplate = new RedisTemplate();
        redisTemplate.setConnectionFactory(connectionFactory);
        return redisTemplate;
    }
}
```

使用RedisTemplate，会使key和value变成二进制码

```java
package com.example.partner.common;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        // 设置key的序列化方式，防止默认的jdk序列化方法出现二进制码
        redisTemplate.setKeySerializer(new StringRedisSerializer()); // key的序列化类型

        // 设置redis的json格式
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,
                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); // value的序列化类型

        redisTemplate.setConnectionFactory(connectionFactory);
        return redisTemplate;
    }
}
```

接下来使用自定义的Redis工具类

RedisUtils.java

```java
package com.example.partner.utils;

import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.concurrent.TimeUnit;

@Component
@SuppressWarnings(value = {"unchecked", "rawtypes"})
public class RedisUtils {

    private static RedisTemplate<String,Object> staticRedisTemplate;

    private final RedisTemplate<String,Object> redisTemplate;

    public RedisUtils(RedisTemplate<String,Object>  redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    // 在springboots启动后执行
    @PostConstruct
    public void initRedis() {
        // 初始化设置 静态staticRedisTemplate对象，方便后续操作数
        staticRedisTemplate = redisTemplate;
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key   缓存的键值
     * @param value 缓存的值
     */
    public static <T> void setCacheObject(final String key, final T value) {
        staticRedisTemplate.opsForValue().set(key, value);
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key      缓存的键值
     * @param value    缓存的值
     * @param timeout  时间
     * @param timeUnit 时间颗粒度
     */
    public static <T> void setCacheObject(final String key, final T value, final long timeout, final TimeUnit timeUnit) {
        staticRedisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public static <T> T getCacheObject(final String key) {
        return (T) staticRedisTemplate.opsForValue().get(key);
    }

    /**
     * 删除单个对象
     *
     * @param key
     */
    public static boolean deleteObject(final String key) {
        return Boolean.TRUE.equals(staticRedisTemplate.delete(key));
    }

    /**
     * 获取单个key的过期时间
     * @param key
     * @return
     */
    public static Long getExpireTime(final String key) {
        return staticRedisTemplate.getExpire(key);
    }
}

```

这时候就可以直接用工具类的配置进行redis缓存

## 12. 集成Sa-Token

依赖：

```java
<dependency>
    <groupId>cn.dev33</groupId>
    <artifactId>sa-token-spring-boot-starter</artifactId>
    <version>${sa-token.vesion}</version>
</dependency>
```

application.yml：

```java
# sa-token配置
sa-token:
  # token 名称（同时也是 cookie 名称）
  token-name: satoken
  # token 有效期（单位：秒） 默认30天，-1 代表永久有效
  timeout: 2592000
  # token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-1 代表不限制，永不冻结
  active-timeout: -1
  # 是否允许同一账号多地同时登录 （为 true 时允许一起登录, 为 false 时新登录挤掉旧登录）
  is-concurrent: true
  # 在多人登录同一账号时，是否共用一个 token （为 true 时所有登录共用一个 token, 为 false 时每次登录新建一个 token）
  is-share: true
  # token 风格默认可取值：uuid、simple-uuid、random-32、random-64、random-128、tik）
  token-style: uuid
  # 是否输出操作日志
  is-log: true
```

MyWebMvcConfig.java：

```java
@Configuration
public class MyWebMvcConfig extends WebMvcConfigurationSupport {
    
    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        // 注册 Sa-Token 拦截器，校验规则为 StpUtil.checkLogin() 登录校验。
        registry.addInterceptor(new SaInterceptor(handle -> StpUtil.checkLogin()))
                .addPathPatterns("/**")
                .excludePathPatterns("/", "/login", "/register", "/email", "/password/reset", "/file/download/**", "/**/export")
                .excludePathPatterns("/dynamic/hot")
                .excludePathPatterns("/swagger**/**", "/webjars/**", "/v3/**", "/doc.html", "/favicon.ico");  // 排除 swagger拦截
    }
}
```

## 13. Sa-Token集成Redis

```java
<!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） -->
<dependency>
    <groupId>cn.dev33</groupId>
    <artifactId>sa-token-redis-jackson</artifactId>
    <version>${sa-token.version}</version>
</dependency>
```

利用Redis缓存存储用户数据，可以有效提高数据库的查询效率，防止二次查询

```java
@GetMapping
public Result findAll() {
    boolean dologin = StpUtil.isLogin();
    log.info("当前是否登录，{}", dologin);
    StpUtil.checkLogin();
    String loginId = (String) StpUtil.getLoginId();
    log.info("loginId：{}",loginId);
    User user = userService.getOne(new QueryWrapper<User>().eq("uid",loginId));
    log.info(user.getName());
    return Result.success(userService.list());
}
```

以上，在数据库查询了两次才获取到了用户数据

```java
StpUtil.getSession().set(Constants.LOGIN_USER_KEY,dbUser);
```

**`StpUtil.getSession()`**: 这是用于获取当前用户的会话 `Session` 对象。如果当前会话不存在，`Sa-Token` 会自动为当前会话创建一个新的 `Session`。

**`set(key, value)`**: 这是 `Session` 对象中的方法，用来在会话中存储键值对数据。会话数据可以在用户登录期间随时获取。

**`Constants.LOGIN_USER_KEY`**: 这是一个常量，用来作为存储用户信息的键，通常指向存储登录用户数据的 `key`。可能在你的项目中定义为类似 `"loginUser"` 或 `"user"` 的常量值。

**`dbUser`**: 这是你从数据库查询到的用户对象，代表当前登录的用户信息。它通常是一个实体对象，包含用户名、角色、权限等信息。

```java
User user = StpUtil.getSession().getModel(Constants.LOGIN_USER_KEY,User.class);
```

**`StpUtil.getSession()`**: 获取当前用户的会话 `Session` 对象。如果会话不存在，`Sa-Token` 会自动创建一个新会话。

**`getModel(String key, Class<T> clazz)`**: 这是 `Session` 对象中的方法，用于获取存储在会话中的对象，并将其转换为指定的类型。`key` 是用来检索数据的键，`clazz` 是指定的类型，用于强制类型转换。

**`Constants.LOGIN_USER_KEY`**: 这是一个常量，用来作为键值去检索存储在 `Session` 中的用户信息。

**`User.class`**: 这是用户类的 `Class` 对象，表示要将存储的用户信息转换成 `User` 类型。

## 14. Sa-Token集成JWT

```java
<!-- Sa-Token 整合 jwt -->
<dependency>
    <groupId>cn.dev33</groupId>
    <artifactId>sa-token-jwt</artifactId>
    <version>${sa-token.version}</version>
</dependency>
```

application.yml：

```java
# jwt秘钥
jwt-secret-key: asdasdasifhueuiwyurfewbfjsdafj
```

## 15. Sa-Token的密码加密（AES）

AES对称加密，加密和解密的钥匙是同一把

```java
// 设置密码加密
user.setPassword(SaSecureUtil.aesEncrypt(Constants.PASSWORD_KEY, user.getPassword()));
```

进行密码加密

```java
String securePass = SaSecureUtil.aesEncrypt(Constants.PASSWORD_KEY, user.getPassword());
if (!securePass.equals(dbUser.getPassword())) {
    throw new ServiceException("用户名或密码错误");
}
```

把输入的密码进行加密，与数据库存入加密后的密码进行对比

## 16. 登录修改

在登录时，我们需要将从后端获取的token返回到前端的Pinia中，获取到token以验证是否登录成功

```java
package com.example.partner.domain;

import com.example.partner.entity.User;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class LoginDTO implements Serializable { // 用来将user序列化和反序列化
    private static final long serialVersionUID  = 1L;

    private User user;
    private String token;
}
```

```java
return LoginDTO.builder().user(dbUser).token(tokenValue).build();
```

想得到时间戳，可以自定义转换器：

LDTConfig.java

```java
package com.example.partner.common;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.ZoneOffset;

public class LDTConfig {


    /**
     * localdatetime 序列化成 13 位时间戳
     * 北京时间
     */
    public static class CmzLdtSerializer extends JsonSerializer<LocalDateTime> {

        @Override
        public void serialize(LocalDateTime value, JsonGenerator gen,
                              SerializerProvider serializers) throws IOException {
            gen.writeNumber(value.toInstant(ZoneOffset.ofHours(8)).toEpochMilli());
        }
    }

    /**
     * 将 13 位时间戳转成 localdatetime
     * 北京时间
     */
    public static class CmzLdtDeSerializer extends JsonDeserializer<LocalDateTime> {

        @Override
        public LocalDateTime deserialize(JsonParser p,
                                         DeserializationContext ctxt) throws IOException {
            long timestamp = p.getLongValue();
            return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.ofHours(8));
        }
    }
}
```

```java
@JsonDeserialize(using = LDTConfig.CmzLdtDeSerializer.class)
@JsonSerialize(using = LDTConfig.CmzLdtSerializer.class)
private LocalDateTime updateTime;
```

## 17. 并发限流算法

为了防止接口被恶意攻击，做一个简易的并发限流算法

首先创建一个自定义的过滤器

MyFilter.java

```java
package com.example.partner.common;


import org.springframework.stereotype.Component;

import javax.servlet.*;
import java.io.IOException;

@Component
public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {
        Filter.super.destroy();
    }
}
```



所有的web请求都会经过doFilter方法，可以通过时间窗口来控制在规定时间内允许通过几个请求，只要控制不通过filterChain.doFilter(servletRequest,servletResponse)这个方法，那么就可以控制请求的通过



```java
package com.example.partner.common;



import cn.hutool.json.JSONUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;

import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.atomic.AtomicInteger;

@Component
@Slf4j
public class MyFilter implements Filter {

    //时间窗口
    // 1秒内通过两个窗口
    private static volatile long startTime = System.currentTimeMillis();;
    private static final long windowTime = 1000L;

    private static final int door = 2;

    private static final AtomicInteger bear = new AtomicInteger(0); // 设置一个桶，用来存储请求次数
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        int count = bear.incrementAndGet(); // 来了一个请求加1
        if(count == 1) {  // 如果多个线程进来，会逐一增加，而不会是多个线程0 + 1
            startTime = System.currentTimeMillis();
        }
         // 发生了请求
        long now = System.currentTimeMillis();
        log.info("请求��量，count：{}",count);
        log.info("时间窗口，startTime：{}，count：{}",(now - startTime),count);
        if(now - startTime <= windowTime) {
            if(count > door) { // 超过了预值
                // 进行限流操作
                log.info("拦截成功,count：{}",count);
                HttpServletResponse response = (HttpServletResponse) servletResponse;
                response.setStatus(HttpStatus.OK.value());
                response.setContentType(MediaType.APPLICATION_JSON_VALUE);
                response.setCharacterEncoding(StandardCharsets.UTF_8.toString());
                response.getWriter().print(JSONUtil.toJsonStr(Result.error("402", "接口请求失败")));
                return;
            }
        } else {
            startTime = System.currentTimeMillis();
            bear.set(1);
        }

        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {
        Filter.super.destroy();
    }
}
```



**`HttpServletResponse response = (HttpServletResponse) servletResponse;`**

- 将 `servletResponse` 对象强制转换为 `HttpServletResponse`，以便对 HTTP 响应进行自定义。

**`response.setStatus(HttpStatus.OK.value());`**

- 设置 HTTP 响应的状态码为 200（OK）。尽管接口请求失败，你依然将状态码设置为 200，可能是为了统一接口返回格式。

**`response.setContentType(MediaType.APPLICATION_JSON_VALUE);`**

- 设置响应的内容类型为 `application/json`，表明返回的数据是 JSON 格式。

**`response.setCharacterEncoding(StandardCharsets.UTF_8.toString());`**

- 设置响应的字符编码为 UTF-8，确保返回的数据能够正确显示中文或其他多字节字符。

**`response.getWriter().print(JSONUtil.toJsonStr(Result.error("402", "接口请求失败")));`**

- 使用 `getWriter()` 方法获取输出流，并通过 `JSONUtil.toJsonStr()` 将自定义的错误结果转换为 JSON 字符串，输出给客户端。`Result.error("402", "接口请求失败")` 创建一个包含错误代码 "402" 和错误消息 "接口请求失败" 的对象。

## 18. 首页布局问题

**`:default-active="$route.path"`**：这里的 `$route.path` 是从 Vue Router 获取的当前路由路径，它会与 `el-menu-item` 的 `index` 属性进行匹配，来自动激活当前的菜单项。

在给表格赋值时，不能直接对**reactive**进行赋值，可以通过**Object.assign(user, res.data)**进行赋值

## 19. 文件上传

### 1. **注入配置参数**

```
java复制代码@Value("${file.upload.path:}")
private String uploadPath;
@Value("${server.port:9090}")
private String port;
@Value("${file.download.ip:localhost}")
private String downloadIp;
```

- **`@Value` 注解**：用于从 `application.properties` 或 `application.yml` 配置文件中读取配置信息。
- **`file.upload.path`**：指定文件上传的路径，默认值为空字符串（`""`），如果未配置，将使用当前项目根目录。
- **`server.port`**：服务器端口，默认为 `9090`。
- **`file.download.ip`**：文件下载的 IP 地址，默认为 `localhost`。

### 2. **上传文件接口**

```
java复制代码@PostMapping("/upload")
public Result upload(MultipartFile file) {
```

- **`@PostMapping("/upload")`**：声明该方法处理 `/upload` 的 `POST` 请求。
- **`MultipartFile file`**：`Spring MVC` 提供的接口，用于处理文件上传。它封装了上传的文件数据。

### 3. **获取文件名和扩展名**

```
java复制代码String originalFilename = file.getOriginalFilename(); // 文件完整名称
String fileName = FileUtil.mainName(originalFilename); // 文件主名称
String extName = FileUtil.extName(originalFilename);   // 获取文件的后缀名
```

- **`file.getOriginalFilename()`**：获取上传的文件的完整名称，例如 `image.jpg`。
- **`FileUtil.mainName()`**：获取文件主名称（不带扩展名部分），例如 `image`。
- **`FileUtil.extName()`**：获取文件扩展名，例如 `jpg`。

### 4. **生成唯一文件名**

```
String uniFileFlag = IdUtil.fastSimpleUUID();
String fileFullName = uniFileFlag + StrUtil.DOT + extName;
```

- **`IdUtil.fastSimpleUUID()`**：使用 `Hutool` 工具生成一唯一的文件标识（UUID）。
- **`StrUtil.DOT`**：常量，表示 `.`，用于拼接扩展名。
- **`fileFullName`**：完整的文件名，由 UUID 和扩展名组成，确保文件名唯一。

### 5. **构建上传路径**

```java
String fileUploadFile = getFileUploadPath(fileFullName); 
```

- **`getFileUploadPath(fileFullName)`**：计算文件在服务器上的完整路径，方法名说明该方法将返回上传路径。

### 6. **检查和创建文件夹**

```java
File uploadFile = new File(fileUploadFile);
File parentFile = uploadFile.getParentFile();
if (!parentFile.exists()) {
    parentFile.mkdir(); // 如果文件夹不存在，则创建文件夹
}
```

- **`new File(fileUploadFile)`**：创建文件���象。
- **`getParentFile()`**：获取父目录，如果不存在就创建文件夹，确保上传目录存在。

### 7. **文件上传**

```
file.transferTo(uploadFile); 
```

- **`file.transferTo(uploadFile)`**：将上传的文件从临时位置复制到指定的磁盘路径。`file.transferTo()` 会将上传的文件保存到服务器上的指定位置。

### 8. **异常处理**

```java
} catch (Exception e) {
    log.error("文件上传失败", e);
    return Result.error("文件上传失败");
}
```

- 如果文件上传过程中发生异常，捕获并记录错误日志，返回错误响应。

### 9. **返回上传结果**

```java
return Result.success("http://" + downloadIp + ":" + port + "/file/download/" + fileFullName);
```

- 成功上传后，返回一个下载 URL，格式为：`http://<downloadIp>:<port>/file/download/<fileFullName>`。
- 这个 URL 是用来访问刚上传的文件的下载路径。

**总结：**

- 该方法接收文件上传请求，生成唯一的文件名并将文件保存到指定的文件夹中。
- 上传完成后返回文件的下载 URL，该 URL 可以用于后续访问和下载该文件。
- 配置了上传文件存储路径、服务器端口和下载服务器的 IP，可以通过配置文件灵活修改这些参数。

#### 1. **定义文件下载接口**

```java
@GetMapping("/download/{fileFullName}")
public void downloadFile(
    @PathVariable String fileFullName, 
    @RequestParam(required = false) String loginId,
    @RequestParam(required = false) String token,
    HttpServletResponse response) throws IOException {
```

- **`@GetMapping("/download/{fileFullName}")`**：声明该方法处理 `GET /download/{fileFullName}` 请求，`fileFullName` 是 URL 路径参数，表示要下载的文件名。
- **`@RequestParam`**：声明了两个可选的参数 `loginId` 和 `token`，用于校验用户的身份和授权。
- **`HttpServletResponse`**：用于返回 HTTP 响应，向客户端发送文件流。

#### 2. **Token 校验**

```java
List<String> tokenList = StpUtil.getTokenValueListByLoginId(loginId);
if (CollUtil.isEmpty(tokenList) || !tokenList.contains(token)) {
    return;
}
```

- **`StpUtil.getTokenValueListByLoginId(loginId)`**：根据 `loginId` 获取与该登录用户关联的所有 `token` 列表。假设你使用了 `Sa-Token` 框架进行用户认证和授权管理。
- **`CollUtil.isEmpty(tokenList)`**：检查 `tokenList` 是否为空如果为空或 `token` 不匹配，则直接返回，不继续执行下载。
- 如果校验通过，则继续处理文件下载逻辑。

#### 3. **获取文件扩展名和文件路径**

```java
String extName = FileUtil.extName(fileFullName);
String fileUploadPath = getFileUploadPath(fileFullName);
```

- **`FileUtil.extName(fileFullName)`**：获取文件的扩展名，例如 `.jpg`、`.docx` 等，用于判断文件类型。
- **`getFileUploadPath(fileFullName)`**：根据文件名获取文件在服务器中的完整存储路径。

#### 4. **读取文件内容**

```java
byte[] bytes = FileUtil.readBytes(fileUploadPath);
```

- **`FileUtil.readBytes(fileUploadPath)`**：使用 `Hutool` 的 `FileUtil` 工具类，将指定路径的文件内容读取为字节数组 `bytes`，用于后续输出到客户端。

#### 5. **设置响应头**

```java
response.addHeader("Content-Disposition", "inline;filename=" + URLEncoder.encode(fileFullName, "UTF-8"));
List<String> attachmentFileExtNames = CollUtil.newArrayList("docx", "doc", "xlsx", "xls", "mp4", "mp3");
if (attachmentFileExtNames.contains(extName)) {
    response.addHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(fileFullName, "UTF-8"));
}
```

- `Content-Disposition`

  ：HTTP 响应头，用于告诉浏览器如何处理响应内容。

  - `inline`：表示文件内容应该在浏览器中直接显示，例如图片、PDF 等。
  - `attachment`：表示文件应该作为附件下载，例如 Word、Excel、视频、音频等文件。

- 判断扩展名是否需要作为附件下载

  ：

  - 使用 `CollUtil.newArrayList()` 创建一个包含文件类型的列表（如 `docx`、`mp4` 等）。如果文件的扩名在这个列表中，则将其作为附件处理。

- **`URLEncoder.encode(fileFullName, "UTF-8")`**：对文件名进行 URL 编码，以避免特殊字符（如空格或非 ASCII 字符）在传输中出现问题。

#### 6. **文件输出**

```java
OutputStream os = response.getOutputStream();
os.write(bytes);
os.flush();
os.close();
```

- **`response.getOutputStream()`**：获取响应的输出流。
- **`os.write(bytes)`**：将文件的字节内容写入到输出流中。
- **`os.flush()`**：强制输出流中的所有数据。
- **`os.close()`**：关闭输出流，完成响应。

**代码流程概述**

1. **Token 校验**：通过 `loginId` 和 `token` 验证请求者的身份。如果校验失败，直接返回，不允许下载。
2. **文件信息处理**：获取文件的扩展名和服务器上文件的完整路径。
3. **读取文件**：将指定路径的文件读取为字节数组。
4. **响应头设置**：根据文件类型设置文件是在线预览还是作为附件下载。
5. **文件流输出**：将文件内容写入 HTTP 响应，发送给客户端。

`loginId` 和 `token` 是通过文件下载的 URL 传递给后端的。这个 URL 是在头像上传成功后，前端拼接的下载地址。在你的代码中，头像上传成功后会执行以下逻辑：

**前端拼接下载 URL：**

当文件上传成功后，前端通过 `handleAvatarSuccess` 回调函数来处理服务器的响应。你将 `loginId` 和 `token` 拼接到了返回的 `res.data`（文件的下载 URL）中：

```javascript
const handleAvatarSuccess = (res) => {
    if (res.code === '200') {
        // 拼接了 loginId 和 token 到下载链接中
        user.avatar = res.data + "?loginId=" + store.getUser.uid + "&token=" + store.getToken;
    } else {
        ElMessage.error('上传失败');
    }
}
```

**URL 拼接后的样子：**

假设 `res.data` 是 `http://localhost:9090/file/download/filename.jpg`，那么拼接 `loginId` 和 `token` 后，`user.avatar` 最终的值会是：

```
http://localhost:9090/file/download/filename.jpg?loginId=12345&token=abcde12345
```

**请求过程：**

1. **上传成功后**：前端将 `res.data`（文件下载 URL）赋值给 `user.avatar`，并在 URL 中附加了 `loginId` 和 `token`。
2. **浏览器加载头像**：浏览器会自动使用 `user.avatar` 加载图片，当浏览器发起这个请求时，会通过 `GET` 请求访问这个 URL，并将 `loginId` 和 `token` 作为查询参数发送给后端。

**后端解析参数：**

在你的后端 `FileController` 中，你的文件下载接口如下：

```java
@GetMapping("/download/{fileFullName}")
public void downloadFile(@PathVariable String fileFullName, 
                         @RequestParam(required = false) String loginId,
                         @RequestParam(required = false) String token,
                         HttpServletResponse response) throws IOException {
    // 验证 token
    List<String> tokenList = StpUtil.getTokenValueListByLoginId(loginId);
    if (CollUtil.isEmpty(tokenList) || !tokenList.contains(token)) {
        return;  // Token 验证失败，拒绝下载
    }
    
    // 文件读取与响应写入逻辑...
}
```

在这个接口中，`loginId` 和 `token` 是通过 `@RequestParam` 从查询参数中解析出来的。也就是说，当用户头像加载时，浏览器会自动发送带有 `loginId` 和 `token` 的下载请求，后端从 URL 中解析这些参数并进行验证。

**问题**

保存头像到数据库时，头像的字段过长，无法保存到数据库，只需要在数据库把长度设置多点

在重启服务器后，发现头像没有加载出来，链接失效了，因为图片里面带了个token，然而token有时间限制，在失效后去后台获取数据时，就获取不到信息了，因此不进行强制验证

## 20. 获取电影电视预告片
在 `TvController` 中添加获取电视预告片的方法：

```java
@ApiOperation(value = "获取电视预告片", notes = "根据电视 ID 获取电视节目的预告片信息")
@GetMapping("/{id}/videos")
public Result getTvVideos(@PathVariable Long id) {
    List<VideoDTO> tvVideos = tvService.getTvVideos(id);
    return Result.success(tvVideos);
}
```

### 1. Service 层实现
确保在 `TvService` 中实现 `getTvVideos(Long id)` 方法，该方法应调用相应的 API 来获取预告片信息。

### 2. 使用 Semaphore 控制并发请求
在获取电视信息的过程中，使用 `Semaphore` 来限制并发请求的数量，以避免对 API 的过度请求。这种方法可以有效地管理并发线程，确保系统在高负载情况下仍能稳定运行。

#### 代码示例：

```java
Semaphore semaphore = new Semaphore(maxConcurrentRequests);

for (int page = 2; page <= totalPages; page++) {
    final int currentPage = page;
    executorService.submit(() -> {
        try {
            semaphore.acquire(); // 获取许可，控制并发请求数量
            // 进行 API 请求的代码
        } catch (InterruptedException e) {
            // 处理异常
        } finally {
            semaphore.release(); // 释放许可
        }
    });
}
```

### 3. 缓存所有热门电影
#### 方法：`cacheAllPopularMovies()`
该方法用于从 API 获取热门电影数据，并将其缓存到 Redis 中。

#### 步骤：
1. **初始化变量**：创建一个 `allMovies` 列表，用于存储所有获取到的电影数据。
2. **获取第一页数据**：使用 `restTemplate` 请求 API 获取第一页的热门电影数据。
3. **存储第一页数据**：将第一页的电影数据添加到 `allMovies` 列表中。
4. **并发请求后续页面数据**：设置每批次最多并发请求的数量（`batchSize`），使用循环从第二页开始请求数据。
5. **等待当前批次完成**：遍历 `batchFutures` 列表，等待每个请求的结果。
6. **排序和缓存数据**：将所有获取到的电影数据按照欢迎度降序排序，并调用 `cacheDataInRedis` 方法将排序后的数据缓存到 Redis。
7. **异常处理**：捕获任何异常并记录错误日志。

#### 代码示例：

```java
public void cacheAllPopularMovies() {
    // ... 代码省略 ...
}
```

### 4. 获取单页电影数据
#### 方法：`fetchMovieData(int page)`
该方法用于获取指定页码的电影数据。

#### 步骤：
1. **请求 API**：使用 `restTemplate` 请求 API 获取指定页码的热门电影数据。
2. **返回结果**：如果返回的数据有效，则返回电影列表；否则返回一个空列表。

#### 代码示例：

```java
private List<MovieDTO> fetchMovieData(int page) {
    // ... 代码省略 ...
}
```

### 5. 缓存数据到 Redis
#### 方法：`cacheDataInRedis(List<MovieDTO> sortedMovieShows)`
该方法用于将排序后的电影数据缓存到 Redis。

#### 步骤：
1. **提取电影 ID**：从排序后的电影列表中提取每个电影的 ID。
2. **计算总页数**：根据每页的大小（`pageSize`）计算总页数。
3. **并发缓存数据**：使用循环遍历每一页，提交异步请求将每页的数据缓存到 Redis。
4. **等待所有缓存操作完成**：遍历 `cacheFutures` 列表，等待每个缓存操作的结果。

#### 代码示例：

```java
private void cacheDataInRedis(List<MovieDTO> sortedMovieShows) {
    // ... 代码省略 ...
}
```

### 6. 获取即将上映的媒体
#### 方法：`getUpComingMedia()`
该方法用于获取缓存中的即将上映的电影的预告片。

#### 步骤：
1. **从 Redis 获取数据**：尝试从 Redis 中获取缓存的电影数据。
2. **检查缓存数据**：如果缓存数据为空，记录警告并返回空列表。
3. **并发获取预告片数据**：对每个电影 ID 提交异步请求以获取预告片数据。
4. **收集结果**：等待所有预告片请求完成，并将有效的预告片添加到结果列表中。
5. **缓存预告片数据**：如果获取到预告片，则将其缓存到 Redis。

### 代码示例：
```java
public List<MediaDTO> getUpComingMedia() {
    // ... 代码省略 ...
}
```

### 7. 获取电影预告片
#### 方法：`fetchMovieTrailer(Long movieId)`
该方法用于获取指定电影 ID 的预告片。

#### 步骤：
1. **请求电影信息**：使用 `restTemplate` 请求 API 获取电影的详细信息。
2. **请求预告片数据**：请求 API 获取该电影的预告片数据。
3. **获取预告片海报**：请求 API 获取该电影的海报数据。
4. **处理海报数据**：检查海报数据是否有效，获取第一张海报的路径。
5. **处理预告片数据**：从预告片数据中筛选出最新的预告片，并将电影名称和海报路径添加到预告片中。

### 代码示例：
```java
private MediaDTO fetchMovieTrailer(Long movieId) {
    // ... 代码省略 ...
}
```

### 8. 使用 Semaphore 控制并发请求

在获取电视信息的过程中，使用 `Semaphore` 来限制并发请求的数量，以避免对 API 的过度请求。这种方法可以有效地管理并发线程，确保系统在高负载情况下仍能稳定运行。

#### 代码示例：

```java
Semaphore semaphore = new Semaphore(maxConcurrentRequests);

for (int page = 2; page <= totalPages; page++) {
    final int currentPage = page;
    executorService.submit(() -> {
        try {
            semaphore.acquire(); // 获取许可，控制并发请求数量
            List<TvDTO> pageData = fetchTvData(currentPage);
            // 处理 pageData
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // 恢复中断状态
        } finally {
            semaphore.release(); // 释放许可
        }
    });
}
```

#### 优化效果：

- **控制并发量**：通过限制同时进行的请求数量，避免了对 API 的过度请求，降低了服务器负载。
- **提高稳定性**：在高并发情况下，能够有效防止因请求过���导致的系统崩溃或响应缓慢。
- **灵活性**：可以根据实际情况动态调整 `maxConcurrentRequests` 的值，以适应不同的负载需求。

### 9. 获取电视预告片的方法

#### 方法：`getTvMedia()`
该方法用于获取电视节目的最新官方预告片。它使用并发请求来提高获取预告片的效率。

#### 代码示例：

```java
public List<MediaDTO> getTvMedia() {
    List<MediaDTO> latestOfficialTrailers = new ArrayList<>();
    int tvCount = 20;
    try {
        int currentPage = 1;
        while (latestOfficialTrailers.size() < tvCount) {
            List<TvDTO> tvDTOList = RedisUtils.getCacheObject("onAirTv:page:" + currentPage);
            if (tvDTOList == null || tvDTOList.isEmpty()) {
                break; // 如果没有数据，则跳出循环
            }
            List<Long> tvIds = tvDTOList.stream()
                    .map(TvDTO::getId)
                    .collect(Collectors.toList());

            List<CompletableFuture<Void>> futures = new ArrayList<>();

            for (Long tvId : tvIds) {
                CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                    try {
                        PopularMovieMediaResponse popularTvResponseDTO = restTemplate.getForObject(apiUrl.getTvVideoUrl(tvId), PopularMovieMediaResponse.class);

                        if (popularTvResponseDTO != null && popularTvResponseDTO.getResults() != null) {
                            List<MediaDTO> trailers = popularTvResponseDTO.getResults().stream()
                                    .filter(video -> "Trailer".equalsIgnoreCase(video.getType()) && "YouTube".equalsIgnoreCase(video.getSite()))
                                    .collect(Collectors.toList());

                            if (!trailers.isEmpty()) {
                                MediaDTO mostRecentTrailer = trailers.stream()
                                        .max(Comparator.comparing(MediaDTO::getPublishedAtAsLocalDateTime))
                                        .orElse(null);

                                String tvBackImage = tvDTOList.stream()
                                        .filter(tv -> tv.getId().equals(tvId))
                                        .map(TvDTO::getBackdrop_path)
                                        .findFirst()
                                        .orElse("无背景图海报");

                                if (mostRecentTrailer != null && tvBackImage != null) {
                                    String tvName = tvDTOList.stream()
                                            .filter(tv -> tv.getId().equals(tvId))
                                            .map(TvDTO::getName)
                                            .findFirst()
                                            .orElse("Unknown Title");

                                    // 获取预告片海报
                                    MovieImagesResponse movieTvImagesResponse = restTemplate.getForObject(
                                            apiUrl.getTvImagesUrl(tvId),
                                            MovieImagesResponse.class
                                    );

                                    if (movieTvImagesResponse != null && movieTvImagesResponse.getBackdrops() != null && !movieTvImagesResponse.getBackdrops().isEmpty()) {
                                        ImageMovieDTO firstImageMovieDTO = movieTvImagesResponse.getBackdrops().get(0);
                                        mostRecentTrailer.setFilePath(firstImageMovieDTO.getFile_path());
                                    } else {
                                        log.error("获取剧集 ID {} 的海报出错（该影片可能没有海报）", tvId);
                                    }

                                    mostRecentTrailer.setBackdrop_path(tvBackImage);
                                    mostRecentTrailer.setMovieTitle(tvName);

                                    // 使用 tvId 和其他字段进行去重
                                    boolean exists = latestOfficialTrailers.stream()
                                            .anyMatch(trailer -> trailer.getMovieTitle().equals(mostRecentTrailer.getMovieTitle())
                                                    && trailer.getPublishedAtAsLocalDateTime().equals(mostRecentTrailer.getPublishedAtAsLocalDateTime()));

                                    if (!exists) {
                                        synchronized (latestOfficialTrailers) {
                                            latestOfficialTrailers.add(mostRecentTrailer); // 添加到最新官方预告片列表中
                                        }
                                    }
                                }
                            }
                        }
                    } catch (Exception e) {
                        System.err.println("获取剧集 ID " + tvId + " 的预告片出错: " + e.getMessage());
                    }
                });

                futures.add(future);
            }

            // 等待所有请求完成
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

            // 如果当前页的预告片数量不足 20，继续请求下一页
            if (latestOfficialTrailers.size() < tvCount) {
                currentPage++;
            }
        }
        // 存储到 Redis，确保 latestOfficialTrailers 不包含 publishedAtAsLocalDateTime
        if (!latestOfficialTrailers.isEmpty()) {
            RedisUtils.setCacheObject("popularTvMedia:", latestOfficialTrailers, 4, TimeUnit.HOURS);
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    return latestOfficialTrailers;
}
```

#### 代码解释：

1. **方法功能**：
   - `getTvMedia()` 方法用于获取最新的电视预告片，并将其存储在 `latestOfficialTrailers` 列表中。

2. **并发请求**：
   - 使用 `CompletableFuture.runAsync()` 方法并发请求每个 `tvId` 的预告片信息，以提高获取效率。

3. **数据处理**：
   - 对于每个 `tvId`，请求其对应的预告片数据，并筛选出类型为 "Trailer" 的视频。
   - 获取最新的预告片，并提取相关信息（如海报、名称等）。

4. **去重逻辑**：
   - 在添加到 `latestOfficialTrailers` 列表之前，检查是否已经存在相同的预告片，以避免重复。

5. **线程安全**：
   - 使用 `synchronized` 关键字确保在多线程环境下对 `latestOfficialTrailers` 列表的访问是线程安全的。

6. **存储到 Redis**：
   - 最后，将获取到的预告片列表存储到 Redis 中，以便后续使用。

### 10. 获取正在播出的电视节目的方法

#### 方法：`getOnAirTvDetails()`
该方法用于获取正在播出的电视节目的详细信息，并使用并发请求来提高获取效率。

#### 代码示例：

```java
public List<TvDTO> getOnAirTvDetails() {
    List<TvDTO> allOnAirTvShows = new ArrayList<>();
    ExecutorService executorService = Executors.newFixedThreadPool(10); // 创建一个线程池
    List<CompletableFuture<List<TvDTO>>> futures = new ArrayList<>();

    try {
        // 获取第一页数据
        int page = 1;
        String url = apiUrl.getTVOnAirUrl(page);
        PopularTvResponseDTO firstPageResponse = restTemplate.getForObject(url, PopularTvResponseDTO.class);

        if (firstPageResponse == null || firstPageResponse.getResults() == null) {
            throw new ServiceException("无法获取正在播出的电视节目");
        }

        // 添加第一页的结果
        allOnAirTvShows.addAll(firstPageResponse.getResults());
        int totalPages = firstPageResponse.getTotalPages();

        // 并发请求后续页面
        for (page = 2; page <= totalPages; page++) {
            final int currentPage = page; 
            CompletableFuture<List<TvDTO>> future = CompletableFuture.supplyAsync(() -> {
                String pageUrl = apiUrl.getTVOnAirUrl(currentPage);
                PopularTvResponseDTO pageResponse = restTemplate.getForObject(pageUrl, PopularTvResponseDTO.class);
                return (pageResponse != null && pageResponse.getResults() != null) ? pageResponse.getResults() : new ArrayList<>();
            }, executorService);
            futures.add(future);
        }

        // 等待所有请求完成并收集结果
        CompletableFuture<Void> allOf = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
        allOf.join(); // 等待所有请求完成

        // 合并所有结果
        for (CompletableFuture<List<TvDTO>> future : futures) {
            allOnAirTvShows.addAll(future.get());
        }

        // 按照首播日期排序
        allOnAirTvShows.sort(Comparator.comparing(TvDTO::getFirst_air_date).reversed()
                .thenComparing(Comparator.comparing(TvDTO::getPopularity).reversed()));

        // 分页存储到 Redis，每页 20 条数据
        int pageSize = 20;
        int totalItems = allOnAirTvShows.size();
        int totalPagesToStore = (int) Math.ceil((double) totalItems / pageSize);

        for (int i = 0; i < totalPagesToStore; i++) {
            int start = i * pageSize;
            int end = Math.min(start + pageSize, totalItems);
            List<TvDTO> pageItems = new ArrayList<>(allOnAirTvShows.subList(start, end));
            RedisUtils.setCacheObject("onAirTv:page:" + (i + 1), pageItems, 4, TimeUnit.HOURS);
        }

    } catch (Exception e) {
        throw new ServiceException("获取正在播出的电视节目时出错", e);
    } finally {
        executorService.shutdown(); // 关闭线程池
    }

    return allOnAirTvShows;
}
```

#### 代码解释：

1. **方法功能**：
   - `getOnAirTvDetails()` 方法用于获取正在播出的电视节目的详细信息，并将其存储在 `allOnAirTvShows` 列表中。

2. **线程池**：
   - 使用 `ExecutorService` 创建一个固定大小的线程池，以便并发请求多个页面的数据。

3. **第一页数据获取**：
   - 首先获取第一页的数据，并检查返回结果的有效性。

4. **并发请求后续页面**：
   - 对于后续页面，使用 `CompletableFuture.supplyAsync()` 提交异步请求，获取每一页的电视节目数据。

5. **等待所有请求完成**：
   - 使用 `CompletableFuture.allOf()` 等待所有异步请求完成，并收集结果。

6. **结果合并与排序**：
   - 合并所有请求的结果，并按照首播日期和受欢迎程度进行排序。

7. **存储到 Redis**：
   - 将获取到的电视节目数据分页存储到 Redis 中，以便后续使用。

### 结论
通过使用并发请求和线程池，这些方法能够有效提高获取电视预告片和正在播出节目的效率，确保系统在高负载情况下仍能稳定运行。

## 21. 个人中心设置待看清单和收藏内容

在应用层逻辑中处理用户的待看清单和收藏内容的删除操作。具体实现如下：

### 1. **逻辑删除用户**

当用户在个人中心选择删除待看清单或收藏内容时，执行逻辑删除操作。通过将 `deleted` 字段设置为 1 来标记记录为已删除，而不是物理删除。

### 2. **更新待看清单和收藏内容**

在用户删除操作中，手动更新与用户相关的待看清单和收藏内容。例如：

```java
public void deleteUser(String uid) {
    // 逻辑删除用户
    userRepository.markUserAsDeleted(uid);

    // 删除与用户相关的待看清单
    watchlistRepository.deleteByUserUid(uid);
    
    // 删除与用户相关的收藏内容
    movieFavoritesRepository.deleteByUserUid(uid);
}
```

### 3. **数据库设计**

确保待看清单和收藏内容表中有 `deleted` 字段，以支持逻辑删除：

```sql
CREATE TABLE movie_favorites (
    id INT AUTO_INCREMENT PRIMARY KEY,
    movie_id INT NOT NULL,
    user_uid VARCHAR(40) NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    deleted INT(1) NOT NULL DEFAULT 0 COMMENT '逻辑删除标记，0为存在，1为删除',
    FOREIGN KEY (user_uid) REFERENCES sys_user(uid)
);
```

### 4. **查询时过滤已删除记录**

在查询待看清单和收藏内容时，确保只返回 `deleted` 字段为 0 的记录：

```java
public List<MovieFavorite> getUserFavorites(String userUid) {
    return movieFavoritesRepository.findByUserUidAndDeleted(userUid, 0);
}
```

### 5. **总结**

通过在应用层实现逻辑删除，您可以有效管理用户的待看清单和收藏内容，同时保留数据以便后续审计或恢复。确保在数据库设计中考虑到逻辑删除的需求，以便在查询和操作时能够正确处理。

## 在登录时获取个人信息的相关数据

在用户登录时，我们需要获取用户的待看清单，并根据每个条目的类型（电影或剧集）进行处理。以下是实现这一功能的步骤和代码示例。

### 问题描述

在用户登录时，我们需要从数据库中获取用户的待看清单，并根据每个条目的类型（电影或剧集）进行处理。我们需要确保能够正确区分每个条目的类型，并将其 ID 传递给外部 API 以获取详细信息。

### 解决方案

1. **查询待看清单**:
   - 使用 `watchlistMapper` 查询用户的待看清单。

2. **提取类型和 ID**:
   - 遍历查询结果，提取每个条目的 `type` 和 `movieId`。

3. **异步获取详细信息**:
   - 使用 `CompletableFuture` 并发请求外部 API，获取每个条目的详细信息。

### 示例代码

```java
public LoginDTO login(UserRequest user) {
    User dbUser = null;
    ExecutorService executorService = Executors.newFixedThreadPool(10);
    try {
        dbUser = getOne(new UpdateWrapper<User>().eq("username", user.getUsername()).or().eq("email", user.getUsername()));
    } catch (Exception e) {
        throw new RuntimeException("数据库异常");
    }
    if (dbUser == null) {
        throw new ServiceException("未找到用户");
    }
    if (!BCrypt.checkpw(user.getPassword(), dbUser.getPassword())) {
        throw new ServiceException("用户名或密码错误");
    }

    // 登录用户
    StpUtil.login(dbUser.getUid());
    log.info("用户已登录，UID: {}", dbUser.getUid());
    StpUtil.getSession().set(Constants.LOGIN_USER_KEY, dbUser);

    String tokenValue = StpUtil.getTokenInfo().getTokenValue();
    log.info("生成的令牌: {}", tokenValue);

    List<Watchlist> watchlists = watchlistMapper.selectList(new QueryWrapper<Watchlist>().eq("user_id", dbUser.getId()));
    List<Map.Entry<String, Long>> typeAndMovieIds = watchlists.stream()
        .map(watchlist -> new AbstractMap.SimpleEntry<>(watchlist.getType(), watchlist.getMovietvId()))
        .collect(Collectors.toList());

    typeAndMovieIds.forEach(entry -> {
        String type = entry.getKey();
        Long movieId = entry.getValue();
        log.info("Type: " + type + ", Movie ID: " + movieId);
    });

    List<CompletableFuture<List<MovieDTO>>> futures = new ArrayList<>();
    CompletableFuture<List<MovieDTO>> future = CompletableFuture.supplyAsync(() -> {
        String idsParam = typeAndMovieIds.stream()
            .filter(entry -> "MOVIE".equals(entry.getKey()))
            .map(entry -> entry.getValue().toString())
            .collect(Collectors.joining(","));
        String urlWithParams = apiUrl.getMovieDetailsUrl() + "?ids=" + idsParam;
        PopularTvResponseDTO pageResponse = restTemplate.getForObject(urlWithParams, PopularTvResponseDTO.class);
        return (pageResponse != null && pageResponse.getResults() != null) ? pageResponse.getResults() : new ArrayList<>();
    }, executorService);
    futures.add(future);

    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

    return LoginDTO.builder().user(dbUser).token(tokenValue).build();
}
```

### 注意事项

- **确保方法存在**: 确保 `Watchlist` 类中有 `getType()` 和 `getMovietvId()` 方法。
- **API 支持**: 确保你的 API 支持通过请求参数或路径参数传递多个 ID。
- **错误处理**: 在发起请求时，添加错误处理逻辑，以便在请求失败时能够捕获和处理异常。

通过这些步骤，你可以在用户登录时提取并处理待看清单中的每个条目，确保在后续请求中可以访问这些数据。

# 离线推荐功能实现

## 1. 数据库设计
首先创建离线推荐结果表，用于存储计算好的推荐结果：
```sql
CREATE TABLE IF NOT EXISTS `recommend_result` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `user_id` varchar(50) NOT NULL COMMENT '用户ID',
  `media_ids` text NOT NULL COMMENT '推荐的媒体ID列表，用逗号分隔',
  `media_type` varchar(10) NOT NULL COMMENT '媒体类型（movie/tv）',
  `scores` text NOT NULL COMMENT '推荐分数，用逗号分隔，与mediaIds对应',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  `is_read` tinyint(1) DEFAULT '0' COMMENT '是否已读',
  PRIMARY KEY (`id`),
  KEY `idx_user_media` (`user_id`,`media_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='推荐结果表';
```

## 2. 实现过程

### 2.1 基础实现
创建实体类和Mapper：
```java
@Data
@TableName("recommend_result")
public class RecommendResult {
    @TableId(type = IdType.AUTO)
    private Long id;
    private Integer userId;
    private Long mediaIds;
    private String mediaType;
    private String scores;
    private LocalDateTime updateTime;
    private Boolean isRead;
}
```

### 2.2 推荐计算优化
实现离线推荐服务，主要包含三种触发机制：

1. 定时触发：
```java
@Scheduled(cron = "0 0 3 * * ?") // 每天凌晨3点执行
@Transactional
public void executeOfflineRecommend() {
    executeOfflineRecommendInternal(false);
}
```

2. 评分触发：
```java
public void checkAndTriggerRecommend(Integer userId) {
    String ratingChangesKey = "recommend:rating_changes";
    Long changes = RedisUtils.increment(ratingChangesKey, 1L);
    RedisUtils.expire(ratingChangesKey, 1, TimeUnit.HOURS);

    if (changes >= MIN_RATING_CHANGES) {
        RedisUtils.deleteObject(ratingChangesKey);
        executeOfflineRecommendInternal(false);
    }
}
```

### 2.3 性能优化
1. 使用Redis控制并发和执行间隔：
```java
private static final String PROCESSING_KEY = "recommend:processing";
private static final String LAST_UPDATE_KEY = "recommend:last_update_time";
private static final int MIN_UPDATE_INTERVAL = 60; // 两次更新的最小间隔（分钟）
```

2. 添加安全机制：
- 使用Redis锁确保同一时间只有一个推荐任务在执行
- 设置最小更新时间间隔，避免频繁计算
- 使用事务确保数据一致性

## 3. 优化过程说明

1. 初始实现：
   - 基础的定时任务，每天凌晨执行一次
   - 简单的ALS模型训练和推荐

2. 第一次优化：
   - 添加评分触发机制，实现实时性
   - 使用Redis计数器统计评分变化

3. 第二次优化：
   - 添加并发控制和执行间隔限制
   - 实现手动触发功能
   - 完善异常处理和日志记录

4. 最终优化：
   - 将推荐逻辑与原有实时推荐结合
   - 优化数据库查询和缓存策略
   - 添加推荐任务的状态监控

这样的设计既保证了推荐结果的及时性，又避免了过于频繁的计算，同时通过多种触发机制满足不同场景的需求。
